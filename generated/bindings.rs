/* automatically generated by rust-bindgen 0.69.4 */

pub const ClipTypeC_ctNone: ClipTypeC = 0;
pub const ClipTypeC_ctIntersection: ClipTypeC = 1;
pub const ClipTypeC_ctUnion: ClipTypeC = 2;
pub const ClipTypeC_ctDifference: ClipTypeC = 3;
pub const ClipTypeC_ctXor: ClipTypeC = 4;
pub type ClipTypeC = ::std::os::raw::c_uint;
pub const JoinTypeC_jtSquare: JoinTypeC = 0;
pub const JoinTypeC_jtBevel: JoinTypeC = 1;
pub const JoinTypeC_jtRound: JoinTypeC = 2;
pub const JoinTypeC_jtMiter: JoinTypeC = 3;
pub type JoinTypeC = ::std::os::raw::c_uint;
pub const EndTypeC_etClosedPolygon: EndTypeC = 0;
pub const EndTypeC_etClosedJoined: EndTypeC = 1;
pub const EndTypeC_etOpenButt: EndTypeC = 2;
pub const EndTypeC_etOpenSquare: EndTypeC = 3;
pub const EndTypeC_etOpenRound: EndTypeC = 4;
pub type EndTypeC = ::std::os::raw::c_uint;
pub const PathTypeC_ptSubject: PathTypeC = 0;
pub const PathTypeC_ptClip: PathTypeC = 1;
pub type PathTypeC = ::std::os::raw::c_uint;
pub type VertexC = [i64; 2usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathC {
    pub vertices: *mut VertexC,
    pub vertices_count: usize,
    pub closed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PathC() {
    const UNINIT: ::std::mem::MaybeUninit<PathC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PathC>(),
        24usize,
        concat!("Size of: ", stringify!(PathC))
    );
    assert_eq!(
        ::std::mem::align_of::<PathC>(),
        8usize,
        concat!("Alignment of ", stringify!(PathC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PathC),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PathC),
            "::",
            stringify!(vertices_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PathC),
            "::",
            stringify!(closed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PolygonC {
    pub paths: *mut PathC,
    pub paths_count: usize,
    pub type_: PathTypeC,
}
#[test]
fn bindgen_test_layout_PolygonC() {
    const UNINIT: ::std::mem::MaybeUninit<PolygonC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PolygonC>(),
        24usize,
        concat!("Size of: ", stringify!(PolygonC))
    );
    assert_eq!(
        ::std::mem::align_of::<PolygonC>(),
        8usize,
        concat!("Alignment of ", stringify!(PolygonC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paths) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PolygonC),
            "::",
            stringify!(paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paths_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PolygonC),
            "::",
            stringify!(paths_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PolygonC),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PolygonsC {
    pub polygons: *mut PolygonC,
    pub polygons_count: usize,
}
#[test]
fn bindgen_test_layout_PolygonsC() {
    const UNINIT: ::std::mem::MaybeUninit<PolygonsC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PolygonsC>(),
        16usize,
        concat!("Size of: ", stringify!(PolygonsC))
    );
    assert_eq!(
        ::std::mem::align_of::<PolygonsC>(),
        8usize,
        concat!("Alignment of ", stringify!(PolygonsC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polygons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PolygonsC),
            "::",
            stringify!(polygons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polygons_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PolygonsC),
            "::",
            stringify!(polygons_count)
        )
    );
}
extern "C" {
    pub fn inflate_c(
        polygons: PolygonsC,
        delta: f64,
        join_type: JoinTypeC,
        end_type: EndTypeC,
        miter_limit: f64,
        arc_tolerance: f64,
    ) -> PolygonsC;
}
extern "C" {
    pub fn intersect_c(subjects: PolygonsC, clips: PolygonsC) -> PolygonsC;
}
extern "C" {
    pub fn union_c(subjects: &PathsC, fill_rule: FillRuleC) -> PathsC;
}
extern "C" {
    pub fn difference_c(subjects: PolygonsC, clips: PolygonsC) -> PolygonsC;
}
extern "C" {
    pub fn xor_c(subjects: PolygonsC, clips: PolygonsC) -> PolygonsC;
}
extern "C" {
    pub fn free_path_c(path: PathC);
}
extern "C" {
    pub fn free_polygon_c(polygon: PolygonC);
}
extern "C" {
    pub fn free_polygons_c(polygons: PolygonsC);
}
